package practice01;
		// 11일차(메서드 오버로딩)
public class practice17 {

	public static void main(String[] args) {
		// TODO Auto-generated method stub

		
//		오버로딩(Overloading)
//		
//		자바에서 한 클래스 내에서 이미 사용하려는 이름과 같은 이름을 가진 메소드가 있덜도 매개 변수의 개수 또는 타입이 다르면
//		같은 이름을 사용해서 메소드를 정의할 수 있다
//		
//		한 클래스 내에 같은 이름의 메소드를 여러 개 정의하는 것을 "메소드 오버로딩" 또는 간단히 "오버로딩"이라 한다
//		
//		메소드 오버로딩 구분 요건
//		1. 메소드 이름이 같아야 한다
//		2. 매개변수의 개수, 타입 또는 순서가 달라야 한다
//		3. 반환 타입은 관계없다.
//		
//		위의 조건을 만족시키지 못하는 메소드는 중복 정의로 간주되어 컴파일 시에 에러가 발생한다
//		그리고 오버로딩된 메소드들은 매개변수에 의해서만 구별될 수 있으므로 반환 타입은 오버로딩을 구현하는데 아무런 영향을 주지 못한다.
//		class Mt02{
//			void p(int a, int b) {
//				System.out.println(a+"\t"+b);
//			}
//			
//			void p(int a) {
//				System.out.println(a);
//			}//전달인자 개수를 다르게 한 메소드 오버로딩
//			
//		  매개변수 개수가 다르다.
//			
//			public static void main(String[] args) {
//				Mt02 m = new Mt02();
//				m.p(100);
//				m.p(100,200);
//			}
//		}
		
//		메소드이름이 같아도 인자의 개수가 다르기 때문에 알아서 인식된다.
		
//		class Mt01{
//			int abs(int a) {
//				if(a<0) {
//					a =-a;
//				}
//				return a;
//			}
//			
//			double abs(double a) {
//				if(a<00) {
//					a=-a;
//				}
//				return a;
//			}
//		}
//		// 매개변수 자료형 타입이 다르다
//		
//		public static void main(String[] args) {
//			Mt01 m = new Mt01();
//			System.out.println("-10의 절대값=" + a.abs(-10));
//			System.out.pritnln("-10.3의 절대값="+a.abs(-10.3));
//		}
		
//		메소드이름이 같아도 인자의 자료형타입이 다르기 때문에 알아서 인식된다.
			
//		매개변수 순서가 다른 경우의 메소드 오버로딩
//			
//		class Mt17{
//			long add(int a, long b) {
//				return a+b;
//			}
//			long add(long a, int b) {
//				return a+b;
//			}
//		} // 매개변수 순서를 다르게 한 메소드 오버로딩
//		매개변수 순서가 다르다
//		public static void main(String[] args) {
//			Mt17 mt = new Mt17();
//			System.out.println(mt.add(3, 5L));
//			System.out.println(mt.add(5L, 3));
//		}
//		
//		메소드이름이 같아도 인자의 순서가 다르기 때문에 알아서 인식된다.
	
//		반환타입은 오버로딩 구현하는데 아무런 영향을 주지 않아 컴파일 에러가 발생한다
//		
//		class Mt03{
//			void p(int a) {
//				System.out.println(a);
//			}
//			int p(int a) {
//				return a;
//			}//메소드 명 앞에 리턴타입을 다르게 한 오버로딩 문법은 적용 안된다
//		}
//		리턴 타입을 다르게 한 오버로딩 문법은 정용 안된다
		
//		this 참조 변수
		
//		인스턴스가 바로 자기 자신을 참조하는 데 사용하는 변수
//		해당 인스턴스의 주소를 가리키고 있다.
//		
//		class Car{
//			String color; // 인스턴스 변수
//			String gearType;
//			int door;
//			
//			Car(String color, String gearType, int door){
//				this.color = color;
//				this.gearType = gearType;
//				this.door = door;
//			}
//		}
//		
//		this는 위 코드처럼 생성자의 매개변수로 선언된 변수의 이름이 인스턴스 변수와 같을 때 인스턴스 변수와 지역 변수를 구분하기 위해 사용한다
//		
//		car() 생성자 안에서의 this.color는 인스턴스 변수이고, color는 매개변수로 정의된 지역변수이다
//		
//		static 메서드에서는 this를 사용하지 못한다.
		
		
//		this() 메서드
//		생성자 내부에서만 사용할 수 있으며 같은 클래스의 다른 생성자를 호출할 때 사용한다
//		
//		인수를 전달하면 생성자 중에서 메서드 시그니처가 일치하는 다른 생성자를 찾아 호출한다.
//		
//		class Car{
//			String color; // 인스턴스 변수
//			String gearType;
//			int door;
//			
//			Car(){
//				this("white","auto",4); // Car(String color, String gearType, int door)를 호출
//			}
//			
//			Car(String color){
//				this(color, "auto", 4);
//			}
//			
//			Car(String color, String gearType, int door){
//				this.color = color;
//				this.gearType = gearType;
//				this.door = door;
//			}
//		}
//		위 코드의 Car()생성자와 Car(String color)생성자는 this()를 통해 모두
//		Car(String color, String gearType, int door)생성자를 호출하고 있는 것이다
		
//		static
//		
//		static은 "고정된" 이라는 의미
//		객체 생성 없이 사용할 수 있는 필드와 메소드를 생성하고자 할 때 활용한다
//		
//		필드나 메소드를 객체마다 다르게 가져야 한다면 인스턴스로 생성하면 되고 
//		공용 데이터에 해당하거나 인스턴스 필드를 포함하지 않는 메소드를 선언하고자 할 때 이용한다
//		
//		사용하기 위해선 클래스 내에서 필드나 메소드 선언 시 static 키워드를 붙여주기만 하면 된다.
		
		// 코드 찍어둔거 입력하기
		
//		final
//		
//		final은 "최종적인" 이라는 의미
//		즉 해당 변수는 값이 저장되면 최종적인 값이 되므로, 수정이 불가능하다는 의미이다
		
		
//		미니 테스트 
//		
//		객체 지향 프로그래밍은 무엇입니까?
//		프로그래밍을 구성하는 요소를 객체로 보고 그 객체간에 상호작용하도록 프로그래밍 하는것
//		
//		객체를 만드려면 반드시 클래스부터 만들어야 하는데 클래스는 현실 세계의 어떤 것의 개념가 비슷한가요?
//		객체를 만들기 위한 틀, 설계도
//		
//		클래스를 만드는 것은 프로그래밍에서 어떻게 표현하나요?
//		클래스를 선언한다
//		
//		new라는 키워드 뒤에 나오는 것을 뭐라고 부르나요?
//		생성자
//		
//		메모리에 만들어진 객체를 뭐라고 부르나요?
//		인스턴스
//		
//		변수의 자료형에는 기본형과 참조형이 있습니다. 기본형의 종류를 작성하시오
//		논리형 boolean 문자형 char 정수형 byte short int long 실수형 float double
//		
//		배열과 클래스는 기본형과 참조형중 어떤 것입니까?
//		참조형
//		
//		new라는 키워드는 클래스를 메모리에 올리라는 뜻입니다. 이렇게 메모리에 올라간 클래스를 무엇이라고 부릅니까?
//		인스턴스
//		
//		'참조한다', '레퍼런스한다'는 프로그래밍에서 어떤 의미를 가지나요?
//		변수가 인스턴스를 가지는것이 아니라 가리킨다는 뜻이다.
//		
//		String str = new String("hello"); 라는 코드에서 str이라는 변수에는 메모리의 어떤 값이 저장되나요?
//		메모리의 위치(주소)값
//		
//		인스턴스는 객체라고 불러도 무방하다고 했습니다. 이유는 무엇일까요?
//		인스턴스는 객체에 포함되기 때문이다
//		
//		String 클래스는 new라는 키워드를 사용하지 않고도 인스턴스를 만들어 낼 수 없다 ()
//		O
//		
//		new라고 나오는 순간 인스턴스를 무조건 힙(heep)메모리 영역에 새로 만든다. 여기서 힙 메모리 영역은 무엇인가요?
//		할당해야 할 메모리의 크기를 프로그램을 실행하는 동안 결정해야 하는 경우 유용하게 사용되는 공간
//		
//		이클립스에서 String 클래스의 변수명에 .(마침표)를 넣으면 어떤 것을 볼 수 있나요?
//		String클래스가 가진 메서드를 볼 수 있다.
//		
//		substring이란 어떤 뜻을 가진 메서드인가요?
//		잘라주세요 라는 뜻
//		
//		String 클래스를 이용하여 인스턴스를 만드는 경우 두 가지를 작성하시오.
//		1. new라는 키워드 없이 만드는 경우
//		2. new라는 키워드를 사용하여 만드는 경우
//			인스턴스는 무조건 새로 만들어진다.
//			
//		아래 코드의 결과값과 그 이유를 작성하시오
//		package javaStudy;
//		public class StringExam{
//			public static void main(String[] args) {
//				String str1 = new String("Hello world");
//				String str2 = new String("Hello world");
//				
//				if(str1 == str2) {
//					System.out.println("str1과 str2는 같은 레퍼런스입니다.");
//				}
//				else {
//					System.out.println("str1과 str2는 다른 레퍼런스입니다.");
//				}
//			}
//		}
//		"str1과 str2는 다른 레퍼런스입니다."

//		자동차라는 객체가 있다면 여기에 자동차의 이름이나 번호가 있다. 이것을 필드라고 하는데 피드를 또 다른 말로 뭐라고 하나요?
//		속성
//		
//		필드는 변수를 선언하는 것과 비슷하게()로 선언할 수 있습니다. ()에 들어갈 말로 알맞은 것을 작성하시오.
//		자료형 필드명
//		
//		필드에 값을 넣고 싶다면 참조 변수 다음에 어떤 것을 입력하면 참조 변수가 참조하는 객체가 가진것들을 사용할 수 있나요?
//		마침표(.)
//		
//		객체지향 언어랑 하나의 사물을 하나의 클래스로 설명하는 언어입니다. 사물에 대한 설명은 그 물체의 상태와 행동으로 나눌 수 있습니다.
//		물체의 상태를 필드라고 하면 물체의 행동은 프로그래밍에서 뭐라고 할까요?
//		메서드
//		
//		입력값을 (가) 혹은 (나)라고 합니다. (가)와 (나)에 들어갈 말로 알맞은 것은?
//		(가): 매개변수
//		(나): 인자
//		
//		(가)와 (나)의 차이점을 작성하시오.
//		1. 매개변수는 전달된 인자를 받아들이는 변수
//		2. 인자는 어떤 함수를 전달되는 값 그 자체를 이야기함
//		
//		결과값은(다)라고 합니다. (다)에 들어갈 말로 알맞은 것은?
//		리턴값
//		
//		메서드를 선언하는 방법을 작성하시오.
//		1. 메서드는(클래스 내부)에 선언한다.
//		2.메서드의 형식: public 리턴형 메서드명(매개변수들) {실행될 코드}
//			
//		리턴형이 없을때는 어떤 예약어를 사용하나요?
//		void		
//				
//		값을 돌려주겠다는 예약어로 어떤 예약어를 사용하나요?
//		return
//				
//		접근 제한자의 개념을 서술하시오.
//		멤버들은 객체 자신들만의 속성이자 특징이므로 대외적으로 공개되는것이 결코 좋은게 아니므로 프로그래머가 멤버들에게 접근 제한을 걸 수 있다.
//		
//		접근 제한자 종류 가지를 작성하시오.
//		1. public 모든 접근을 허용
//		2. protected 같은 패키지내에 있는 객체와 상속관계의 객체들만 허용
//		3. default 같은 패키지에 있는 객체들만 허용
//		4. private 현재 객체 내에서만 허용
//		
//		일반적으로 변수와 클래스를 하나로 묶는 작업을 캡슐화라고 합니다. 캡슐화의 목적을 작성핫오.
//		중요한 데이터를 보존, 보호하기 위해
//		
//		캡슐화는 어떤 용어랑 같은 말인가요?
//		은닉성
//		
//		캡슐화하는 방법 두 가지를 작성하시오.
//		1. 멤버 변수 앞에 접근 제한자 private 를 붙인다
//		2. 멤버 변수에 값을 넣고 꺼내 올 수 있는 메소드를 만든다
//		
//		클래스를 2개 이상 사용하는 이유는 무엇인가?
//		프로그램의 구조화, 모듈화, 코드의 재사용성, 유지보수 등 다양한 이점을 얻기 위해서
//		
//		함수(메서드)의 인자 호출 방식 두 가지를 작성하시오.
//		1. call by value 값에 의한 호출
//		2. call by reference 참조에 의한 호출
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
	}

}
