package practice01;
		// 10일차(객체지향)
public class practice16 {

	public static void main(String[] args) {
		// TODO Auto-generated method stub

		
//		자바는 객체지향 언어이다
//		
//		프로그래밍을 구성하는 요소를 객체로 보고 그 객체 간에 상호 작용하도록
//		프로그래밍하는 것을 객체지향 프로그래밍이라고 한다
//		
//		객체지향 프로그래밍에서 객체로 도출 가능한 것은 사람, 사물, 장소, 개념등이다
//		각 객체는 스스로의 속성을 알고, 그 기능을 가지고 있다
		
//		자바에서 객체를 만들어보자
//		자바에서 객체를 만들려면 반드시 클래스를 먼저 만들어야 한다
//		클래스는 객체를 만들기 위한 일종의 틀이다
//		예를 들어 붕어빵이 객체라면 붕어빵을 만들어내는 틀은 클래스이다
//		자동차 객체가 필요하다면 자동차 클래스를 먼저 만들어야 한다
		
//		쉽게 클래스는 객체를 만들기 위한 설계도이다
//		
//		자동차라는 객체를 만들기 전에 이 자동차라는 객체가 어떤 속성을 가져야 하는지, 어떤 기능을 가져야 하는지
//		필요한 사항을 꼼꼼히 설계해야 한다
//		
//		이런 설계도를 자바에서는 클래스라고 한다.
		
//		설계도가 없다면 자동차를 한 대 만들때마다
//		여러 사항들을 모두 고려하고 만들어야 한다.
//		
//		설계도를 하나 만들어놓으면 설계도 하나를 통해
//		얼마든지 많은 자동차를 만들어낼 수 있다
//		
//		클래스는 보통 클래스를 선언한다고 이야기한다
//		
//		public class 뒤에 클래스 명을 적는다
//		클래스 블록을 만들어서 그 안에 필요한 구성 요소를 넣어준다
//		
//		public class 클래스면 {...}
		
//		public class Car{...}
//		
//		Car 클래스에는 아무것도 없다
//		
//		마치 붕어빵 틀을 만드는 것과 비슷하다
//		하지만 붕어빵 틀을 만들었다고 해서 자동으로 붕어빵이 만들어지는 것은 아니다.
		
//		public class Car{
//			public static void main(String[] args) {
//				
//			}
//		}
//		
//		메인 메서드를 만든다
//		아래는 객체를 만든 예시이다.
//		public class Car{
//			public static void main(String[] args) {
//				Car c1 = new Car();
//			}
//		}
		
//		public class Car{
//			public static void main(String[] args) {
//				Car c1 = new Car();
//				Car c2 = new Car();
//			}
//		}
//		
//		new라는 키워드 뒤에 나오는 Car을 생성자라고 한다
//		이 코드는 생성자를 이용해서 메모리에 객체를 만들라는 명령이다
//		
//		메모리에 만들어진 객체를 인스턴스라고도 부른다
//		이렇게 만들어진 객체를 참조하는 변수가 c1이다
//		
//		작성한 코드 두 줄을 실행하면 Car라는 객체가 두 개 만들어지고,
//		각각의 객체를 참조하는 변수 두개와 c1,c2가 선언된다.
		
		// 참조형
		
//		자바는 변수를 선언하려면 반드시 변수의 자료형을 정해줘야 한다.
//		
//		변수의 자료형에서는 기본형과 참조형이 있다
//		기본형은 앞서 배운 논리형, 문자형, 정수형, 실수형 총 8개이다
//		논리형 boolean
//		문자형 char
//		정수형 byte short int long
//		실수형 float double
//		
//		이 기본형들은 클래스가 아니다
//		
//		참조형은 기본형을 제외한 모든 형을 말한다
//		앞서 배운 배열도 참조형이고, 클래스도 참조형이다.
		
//		우선, 기본형 변수 하나 int i =4라고 선언한다
//		이 코드는 i라는 4바이트 크기의 정수형 변수에 숫자 4를 저장한다는 뜻이다
//		package javaStudy;
//		public class Type{
//			public static void main(String[] args) {
//				int i = 4;
//			}
//		}
		
//		이번에는 참조형 변수를 하나 선언하겠다.
//		String이라는 클래스를 이용해 참조형 변수 str을 선언했다.
//		package javaStudy;
//		public class ReferenceDataType{
//			public static void main(String[] args) {
//				int i = 4;
//				String str = new String("hello");
//			}
//		}
//		
//		코드를 보면 변수 앞에 기본형이 아닌 String이라는 클래스가 적혀있다.
//		대입 연산자(=) 뒤에는 new 다음에 생성자가 있다.
//		(생성자는 곧 배울 예정이므로 여기서는 '생성자가 있구나'라고만 생각하자)
		
//		new라는 키워드는 클래스를 메모리에 올리라는 뜻이다
//		이렇게 메모리에 올라간 클래스를 인스턴스라고 한다
//		
//		메모리에 올라간 인스턴스를 가리키는 변수, 참조하는 변수,
//		레퍼런스하는 변수가 str이라는 변수이다
//		
//		참조한다 레퍼런스한다는 것은 변수가 인스턴스를 가지는 것이 아니라 말 그대로 가리킨다는 의미이다
//		
//		변수 str에 String 인스턴스가 있는 것이 아니라 다른 메모리 영역에 있는 String이라는 인스턴스를 변수 str이 가리킨다.
//		
//		String str = new String("hello");
//		
//		str -----참조한다-----hello
//							String객체
		
//		즉 str이라는 변수에는 메모리의 위치(주소)값이 저장된다.
//		
//		메모리 위치 값을 저장한다 하더라도 어떤 메모리에 저장하는지 그정보를 아는 방법은 없다
//		그러므로 str변수는 String인스턴스를 참조한다고만 알아두면 된다
//		
//		앞으로 배울 클래스는 모두 이와 같은 참조형임을 기억해 두자
		
//		참조형 변수 정리
		
//		String str = new String("hello");
//		
//		str 변수 앞에 기본 자료형이 아닌 String 클래스가 적혀있다
//		
//		(=)뒤에는 new다음에 생성자라는 것이 있다
//		
//		new라는 키워드는 클래스를 메모리에 올려준다. 이렇게 메모리에 올라간 클래스를 인스턴스라고 한다
//		
//		메모리에 올라간 인스턴스를 가리키는 변수 참조하는 변수 레퍼런스하는 변수가 str이다
//		변수가 인스턴스를 가지는 것이 아니라 말 그대로 가리킨다는 의미이다
//		
//		str이라는 변수에는 메모리의 위치 값을 저장한다 어떤 메모리에 저장하는지 안 수 있는 방법은 없기 때문에
//		str변수는 String 인스턴스를 참조한다.
//		앞으로 배울 클래스들은 모두 참조형이다.
		
//		객체, 클래스, 인스턴스 등 용어 정리
//		
//		객체는 우리가 소프트웨어 세계에 구형해야 할 대상이다
//		객체를 구현하기 위한 설계도가 클래스이다
//		
//		클래스라는 설계도에 따라 소프트웨어 세상에 구현된 실체가 인스턴스이다
//		클래스를 메모리에 올려 인스턴스를 만드는 과정을 인스턴스화라고 한다
//		
//		실체화된 인스턴스는 메모리에 할당된다. 인스턴스를 객체라고 불러도 무방하다.
//		개념적으로 인스턴스는 객체에 포함된다고 볼 수 있기 때문이다.
		
//		이번에는 자바에서 가장 많이 사용하는 클래스인 String 클래스를 알아보자
//		
//		우리가 이때까지 알게 모르게 String클래스를 사용했다.
//		예를 들어 main메서드에서도 String클래스를 볼 수 있다.
//		
//		package javaStudy;
//		public class StringExam{
//			public static void main(String[] args) {
//				
//			}
//		}
		
//		String은 클래스이면서도 동시에 데이터 타입으로 취급된다.
//		특별한 취급을 받기 때문에 혼란스럽겠지만 이러한 구분은 자바의 설계와 역사적인 이유 때문에 발생한다
//		
//		String은 가장 많이 사용되는 클래스인 만큼 자바에서도 특별하게 취급한다.
//		
//		먼저 모든 클래스는 new 연산자를 사용해야 되는데 
//		String클래스는 new라는 연산자를 이용하지 않고도 인스턴스를 만들어낼 수 있다.
		
//		String str1 = "hello";
//		String str2 = "hello";
//		
//		String str3 = new String("hello");
//		String str4 = new String("hello");
//		
//		str1, str2라는 변수 옆에 기본 자료형에서 했던 것처럼 바로 값을 넣어도 인스턴스가 생성된다.
//		물론 str3, str4처럼 일반 클래스와 똑같이 new를 이용해도 된다
//		
//		new를 사용하지 않으면 똑같은 문자열일 경우 같은 메모리 공간을 사용한다
//		str1,str2는 같은 문자열을 참조하게 된다. new를 사용하면 같은 문자열이어도 매번 메모리에 새롭게 할당된다
//		String 클래스는 다른 클래스와 다르게 new를 사용하지 않고 사용할 수 있으므로 
//		메모리를 아끼려면 new를 사용하지 않고 사용하는것이 좋다.
		
//		다음으로 str3와 str4는 new 키워드를 이용해서 만들었다
//		
//		String str3 = new String("hello");
//		String str4 = new String("hello");
//		
//		new 키워드로 인스턴스를 만들면 상수 영역을 참조하지 않는다. new 라고 나오는 순간 인스턴스를 무조건 힙(heep)메모리 영역에 새로 만든다.
//		그래서 str3와 str4는 각각 인스턴스를 하나씩 생성한다. 그리고 각각 만든 hello라는 문자열을 가리킨다
//		
//		힙(heep)메모리 영역이란 할당해야 할 메모리의 크기를 프로그램을 실행하는 동안 결정해야 하는 경우(런 타임때) 유용하게 사용되는 공간이다
//		기본 데이터 타입은 항상 크기가 동일하지만 객체들은 생성시에 크기가 다를 수 있으므로 힙에 생성한다.
		
//		각 변수가 가리키는 주소가 같은지, 다른지 비교하겠다.
//		str1가 str2가 같은 영역을 가리키는지 확인하기 위해 두 변수를 비교하는 코드를 if문으로 작성했다.
//		if문을 블록으로 감싸지 않으면 한 문장만 실행된다. 따라서 if문 괄호 속 조건이 맞으면 우리가 원하는 문장이 출력될 것이다.
//		
//		if(str1 == str2)
//		System.out.println("str1과 str2는 같은 레퍼런스입니다");
		
//		if(str1 == str3)
//			System.out.println("str1과 str3는 같은 레퍼런스입니다");
//		if(str3 == str4)
//			System.out.println("str3과 str4는 같은 레퍼런스입니다");
//		
//		실행 결과는 아무것도 출력되지 않는다
//		str1과 str3 그리고 str3과 str4는 서로 다른 인스턴스를 가리킨다는 의미이다
		
//		String 클래스의 또 다른 특징 중 하나는 한 번 실행한 클래스는 변하지 않는다는 것이다
//		다른 클래스는 그렇지 않다. String 클래스만 독특한 것이라고 생각하면 된다.
		
//		이클립스에서 str1옆에 .(마침표)를 넣어보자
//		String클래스가 가진 메서드들을 볼 수 있다.
		
//		String 클래스는 자주 사용하는 클래스인 만큼 메서드도 굉장히 많다.
		
//		그 중에서 substring이란 메서드를 수행하겠다. 이 메서드는 "잘라주세요."라는 뜻이다
		
//		옆의 괄호에 "3"이라고 넣어준다 즉 이 코드의 의미는 "인덱스가 3번인 것부터 잘라서 보여주세요."라는 뜻이다
//		System.out.println(str1.substring(3));
//		출력은 lo가 된다
		
//		인스턴스 생성 방법 정리
//		1. new 키워드 없이 인스턴스를 만드는경우
//		   "hello"라는 문자열이 메모리 중 상수를 저장하는 영역에 저장된다
//		    두번째문장이 실행될때 hello라는 문자열 상수가 이미 만들어졌으므로 str1이 참조하는 인스턴스를 str2도 참조한다
//		
//		2. new 키워드로 인스턴스를 만드는 경우
//		
//		   인스턴스는 무조건 새로 만들어진다
//		   두번째문장이 실행될 때도 새로 만들고 str3과 str4는 서로 다른 인스턴스를 참조한다
		
//		클래스의 구성 요소인 필드에 대해서 알아보자
//		
//		자동차라는 객체가 있다 앞에서 Car이라는 객체를 만들었다.
//		자동차에 이름이나 번호가 있는데 이것을 속성이라고 한다.
//		이런 속성을 필드(field)라고 한다.
//		
//		필드는 코드에서 변수로 표현된다.
//		변수를 선언하는 것과 비슷하게 '자료형 필드명'으로 선언할 수 있다.
//		
//		필드에 값을 넣고 싶다면 참조 변수 다음에 마침표(.)를 입력하면 
//		참조 변수가 참조하는 객체가 가진 것들을 사용할 수 있다.
		
//		1. 이름과 번호를 필드로 가진 Car 클래스 선언
//		public class Car{
//			String name;
//			int number;
//		}
//		
//		2. Car 클래스를 인스턴스화하기
//		
//		Car c1 = new Car();
//		Car c2 = new Car();
//		// Car라는 인스턴스가 메모리에 두 개 만들어집니다
//		// 객체별로 name과 number라는 필드를 가집니다
		
//		3. 속성 이용하기
//		
//		c1.name은 c1이 참조하는 객체의 name을 의미합니다
//		
//		c1.name = "소방차"; //c1이 참조하는 객체의 name을 소방차로 설정
//		c1.number = 1234; //c1이 참조하는 객체의 number를 1234로 설정
//		
//		c2.name = "구급차"; //c2가 가리키는 객체의 name을 구급차로 설정
//		c2.number = 1111; //c2가 가리키는 객체의 number를 1111로 설정
//		
//		System.out.println(c1.name);   // 콘솔에 c1이 참조하는 객체의 name을 출력
//		System.out.println(c1.number); // 콘솔에 c1이 참조하는 객체의 number을 출력
		
//		메서드
//		
//		객체지향 언어란 하나의 사물을 하나의 클래스로 설명하는 언어이다.
//		
//		사물에 대한 설명은 그 물체의 상태와 행동으로 나눌 수 있다.
//		
//		물건의 상태 = 필드, 물체의 행동 = 메서드
		
//		자동차를 생각하면 이름과 번호라는 속성도 있지만
//		전진하거나 후진하는 행동도 있다
//		이름, 번호 = 피드
//		전진, 후진하는 행동 = 메서드
		
//		메서드는 입력값이 있고 그 입력값을 받아서 무언가를 한 다음에
//		결과를 도출해내는 수학의 함수와 비슷한 개념이다.
		
//		입력값을 매개변수 혹은 인자, 결과값을 리턴값이라고 한다.
//		영어로는 매개변수를 파라미터, 인자를 아규먼트라고 한다
//		
//		매개변수와 인자의 차이점
//		1. 매개변수는 전달된 인자를 받아들이는 변수
//		2. 인자는 어떤 함수를 전달되는 값 자체를 이야기함
//		
//		public void method(int i, String str) {
//			
//		}
//		method(10, "abc");
//		i, str 은 매개변수라고 하고 이 메서드를 호출해 사용할때
//		10과 abc는 인자라고 한다.
		
//		메서드 선언하는 방법
//		
//		메서드는 클래스 내부에 선언한다.
//		
//		public 리턴형 메서드명(매개변수들) {실행될 코드}
//		
//		리턴형 : 메서드를 실행한 다음 결과값을 되돌려줄 때 사용하는 자료형
//		
//		메서드는 리턴형 유무나 매개변수 유무들에 따라 다양한 형태로 정의 가능
		
//		메서드를 보면 돌려줄 값 즉 리턴값이 없다.
//		
//		하지만 리턴형이 없다고 해서 생략할 수는 없다
//		리턴형은 반드시 적어줘야 한다.
//		
//		리턴형이 없을때는 void라는 예약어를 적어준다.
//		
//		void라는 예약어는 리턴형이 없다는 뜻으로 기억하면 된다.
//		
//		괄호 속은 매개변수이다
//		하지만 매개벼누도 없기 때문에 비워둔 상태로 메서드를 선언한다.
//		
//		이후 오는 중괄호 안에 메서드를 실행했을 때 해야 할 일들을 구현하면 된다.
//		
//		public class myClass{
//			// public 리턴형 메서드명(매개변수들){필요한 기능 구현}
//			public void method(){
//				System.out.println("m1이 실행됨");
//			}
//		}
		
//		정수를 입력받아 뭔가를 수행하고 리턴은 하지 않는 메서드이다.
//		
//		public void method2(int x) {
//			System.out.println(x+"을 이용한 m2실행");
//		}
//		
//		아무것도 리턴하지 않기 때문에 void라고 적는다.
//		매개변수 부분에는 정수를 입력받기 때문에 int형을 작성한다
//		
//		매개변수가 들어왔을 때 그 값을 받아낼 그릇 즉 변수 x를 하나 정의해 둔다
//		실행하고 결과값은 돌려주지 않는다.
		
//		아무것도 입력되지 않았지만, 뭔가를 수행해서 값을 돌려주는 메서드
//		이 코드는 리턴이 있기 때문에 med3를 실행한 후 반드시 정숫값을 돌려준다
//		즉 값을 돌려주겠다는 예약어로 return을 사용하고, 10이라는 값을 리턴한다.
//		
//		public void method3() {
//			System.out.println("m3 실행");
//			return 10;
//		}
		
//		값을 받아서 값을 출력하는 형태
//		public void method5(int y) {
//			System.out.println(y+"이용한 m5 실행");
//			return y+2;
//		}
		
//		메서드 사용하기
//		1. 클래스 만들기
//		2. 메서드 사용
//		
//		단, 클래스가 가진 메서드를 사용하려면 먼저 객체로 만들어야 한다
//		즉 클래스 이름을 MyClass라고 하면 이 클래스가 가진 메서드를 사용하기 위해서 반드시 MyClass를 객체로 만들어야 한다
//		
//		쉽게 붕어빵 틀이 있어도 붕어빵을 만들어내지 않는다면 붕어빵을 먹을 수 없는 것과 같다
		
//		접근 제한자
//		멤버들은 객체 자신들만의 속성이자 특징이므로 대외적으로 공개되는 것이 결코 좋은게 아니므로 프로그래머가 멤버들에게 접근 제한을 걸 수가 있는데
//		자바에서는 이를 접근 제한자라 한다
//		
//		접근 제한자 종류
//		1. public 모든 접근을 허용
//		2. protected 같은 패키지(폴더)에 있는 객체와 상속 관계의 객체들만 허용
//		3. default 같은 패키지에 있는 객체들만 허용
//		4. private 현재 객체 내에서만 허용
		
//		접근 제한자 별 사용 가능 범위
//		1. 클래스 : public default
//		2. 생성자 : public protected default private
//		3. 멤버 변수 : public protected default private
//		4. 멤버메소드 : public protected default private
//		5. 지역변수 : 접근 제한자 사용 불허
		
//		캡슐화
//		일반적으로 변수와 클래스를 하나로 묶는 작업
//		
//		캡슐화의 목적
//		중요한 데이터를 보존, 보호하기 위해 사용하는 것
//		
//		정리하자면, 캡슐화는 클래스에 담는 내용 중 중요한 데이터나 기능을 외부에서 접근하지 못하게 하기 위해서 사용한다고 알아 두면 된다.
//		캡슐화 = 은닉성
		
//		캡슐화 방법
//		1. 멤버 변수 앞에 접근 제어자 private를 붙인다
//		(private : 자기 클래스에서만 접근할 수 있는 것)
//		
//		2. 멤버 변수에 값을 넣고 꺼내 올 수 있는 메소드를 만든다
//		(접두어 set/get 을 사용해 메소드를 만든다)
//		
//		구체적으로 학생이란 클래스와 학교라는 클래스를 만들었다고 가정
//		학생이라는 클래스에서 학생들의 나이에는 private가 붙는다
//		즉 은닉화가 되었다
//		이때 학교 클래스에서 학생의 정보를 호출하려고 하면 평소의 방법으로는 접근이 되지 않는다
//		예제를 보자
//		
//		school, student 서로 다른 2개의 클래스가 있다.
//		
//		student의 멤버변수들에 private를 붙여 은닉화 시켰다.
//		그 후 school클래스에서 이 student의 멤버 변수를 조작하는 것은 곧 배울 예정인 this가 붙은 메소드를 활용하면 된다
//		
//		하지만 호출이 문제이다
//		앞서 배웠듯이 stu.age처럼 하면 오류가 발생한다
//		
//		이유는 은닉화가 되어있기 때문에 바로 접근할 수가 없으므로 예제처럼 set/get등 접두사를 사용하여
//		메소드를 이용해 간접적으로 접근한다.
		// 내일 코드 작성
	
//		클래스를 2개 이상 사용하는 이유
//		
//		프로그램의 구조화, 모듈화, 코드의 재사용성, 유지보수 등 다양한 이점을 얻기 위해서이다
//		
//		클래스는 객체지향 프로그래밍의 기본 단위이며, 여러 개의 클래스를 사용함으로써 각 클래스가 특정 기능을 담당하고
//		관련 기능들을 묶어서 사용함으로써 프로그램을 보다 효율적으로 작성할 수 있다.
		
//		함수(메소드)의 인자 호출 방식
//		1. call by value
//		2. call by reference
//		
//		말 그대로 '값에 의한 호출','참조에 의한 호출'이다
//		
//		기본 타입으로 전달되는 경우
//		byte, char, int, double 등 자바의 기본 타입이 인자로 전달되는 경우에는 호출자가 건네는 인자의 값을 복사하여 메소드의 인자에 전달한다
		
		// 코드 입력하기
//		메소드 swap은 두개의 변수의 값을 서로 교환하는 기능을 수행하는 메소드이다
//		
//		메소드 swap을 사용했음에도 불구하고 num1,2값은 변화가 없다
//		
//		메소드 안에서 위치를 바꾼다고 해서 원본 데이터가 바뀌는 것이 아니라는 것을 알수있다
//		위 코드 메소드 내에서 두 수를 바꾸는 것은 단지 복사된 값을 바꾸는 것이다
//		
//		따라서 자바는 기본 데이터 타입이 인자로 전달되는 경우는 1. call by value(값에 의한 호출)로 처리된다
		
//		call by value(값에 의한 호출)은 메소드 호출 시에 사용되는 인자의 메모리에 저장되어 있는 값을 복사하여 보낸다
//		
//		객체 레퍼러느가 인자로 전달되는 경우
//		
//		메소드 인자로 객체에 대한 레퍼런스가 전달되는 경우 객체가 통으로 전달되는 것이 아니라 레퍼런스 값만 복사되어 전달된다
//		
//		이런 경우 커스텀 클래스를 사용한다
//		
//		위 코드에서는 참조값을 직접 바꾼것이 아니라 객체의 참조값을 통해 그 객체의 멤버변수에 접근해 값을 바꾼것이다
//		
//		힙 영역(Number Class의 인스턴스들인 num1 2가 힙 영역에 저장)에서 참조 되어지는 값 자체를 바꾸어 call by reference 처럼 보이게 한 것이다
//		
//		중요한 것은 자바에서 메소드 호출 시 객체가 전달되는 경우 객체에 대한 레퍼런스만 복사되지 객체가 통째로 복사되지 않는다.
		
		
		
		
		
		
		
	}

}
